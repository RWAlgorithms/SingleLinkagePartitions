var documenterSearchIndex = {"docs":
[{"location":"api/#Function-References","page":"Public API","title":"Function References","text":"","category":"section"},{"location":"api/#Core","page":"Public API","title":"Core","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"geteuclideanmetric","category":"page"},{"location":"api/#SingleLinkagePartitions.geteuclideanmetric","page":"Public API","title":"SingleLinkagePartitions.geteuclideanmetric","text":"geteuclideanmetric()\n\nConvinence constructor for a DistancesjlMetric type that SingleLinkagePartitions utilizes. returns DistancesjlMetric(Distances.Euclidean())\n\n\n\n\n\n","category":"function"},{"location":"api/#Partition-construction","page":"Public API","title":"Partition construction","text":"","category":"section"},{"location":"api/#Dispatch-types/traits/configs","page":"Public API","title":"Dispatch types/traits/configs","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"UseMaxDeviation","category":"page"},{"location":"api/#SingleLinkagePartitions.UseMaxDeviation","page":"Public API","title":"SingleLinkagePartitions.UseMaxDeviation","text":"struct UseMaxDeviation{T <: AbstractFloat} <: LevelOption\n    max_dev::T # a positive number that specifies a level from a partition tree. For use with `picklevel`.\n\n    # the following are tuning parameters for use with `iteratedsl`.\n    max_iters::Int\n    search_convergence_atol::T\n    verbose::Bool\nend\n\nDispatch type/trait, for use with picking a level via picklevel or iterated single-linkage via iteratedsl.\n\nTerminology: Given a point set X on a D-dimensional vector space, we define the maximum deviation of a partition P_X of X as:\n\nρ = maximum(\n    maximum(\n        maximum(\n            abs(a[d]-mean(A)[d])\n            for a in A\n        )\n        for A in P_X\n    )\n    for d in 1:D\n)\n\nIf we order the partitions of a partition tree such that the next partition merges two of the parts in the current partition, i.e. in a nesting order, then the sequence of maximum deviations of the ordered partitions is approximately monotonically increasing. This is because a partition with larger sized parts (partitions in the latter parts of the sequence) in general have more variability within their larger sized parts than a partition with smaller sized parts (partitions in the beginning parts of the sequence).\n\nDescription: The UseMaxDeviation trait/config data type specifies that we should choose a partition from a partition tree such that the chosen partition has a maximum deviation that is approximately the best match to a user-specified target value, which is stored as the max_dev struct field.\n\nThe reason the implemented methods associated with UseMaxDeviation does not guaranteed to return the best match is because the sequence of maximum deviations that corresponds to the nesting order of partitions is not guaranteed to be monotonic.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"Public API","title":"Public API","text":"UseSLDistance","category":"page"},{"location":"api/#SingleLinkagePartitions.UseSLDistance","page":"Public API","title":"SingleLinkagePartitions.UseSLDistance","text":"struct UseSLDistance{T} <: LevelOption\n    atol::T\nend\n\nTerminology: The partitions of two consecutive levels in any partition tree pt is such that the larger level corresponds to a larger partition that contains the partition that corresponds to the smaller level. The part/cluster that merged as we traverse from level l to level l+1 is the merging distance of the two levels.\n\nDescription: UseSLDistance specifies the threshold merging distance of level l and l+1. For use with picklevel(.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"Public API","title":"Public API","text":"UseCumulativeSLDistance","category":"page"},{"location":"api/#SingleLinkagePartitions.UseCumulativeSLDistance","page":"Public API","title":"SingleLinkagePartitions.UseCumulativeSLDistance","text":"struct UseCumulativeSLDistance{T} <: LevelOption\n    atol::T\nend\n\nSee UseSLDistance for a description on merging distances.\n\nUseCumulativeSLDistance specifies the threshold on the cumulative merging distance from level 0 to l. For use with picklevel(.\n\n\n\n\n\n","category":"type"},{"location":"api/#Functions","page":"Public API","title":"Functions","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"computesl","category":"page"},{"location":"api/#SingleLinkagePartitions.computesl","page":"Public API","title":"SingleLinkagePartitions.computesl","text":"computesl(\n    metric::Union{DistancesjlMetric, InnerProductNorm},\n    X::Union{Vector{Vector{T}}, Vector{Vector{Complex{T}}}},\n    )::PartitionTree{T} where T <: AbstractFloat\n\nComputes and returns the single-linkage partition tree of X, with respect to distance metric, metric. The partitions in the tree are specified by a level index from 0 to maxlevel(pt), where pt is the returned PartitionTree variable.\n\nSee getpartition to select a partition by its level from the return partition tree.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"picklevel","category":"page"},{"location":"api/#SingleLinkagePartitions.picklevel","page":"Public API","title":"SingleLinkagePartitions.picklevel","text":"picklevel(C::UseSLDistance, pt::PartitionTree{T}, args...)::Int where T <: AbstractFloat\n\nSee UseSLDistance for a description of merging distance. Returns the partition for first level l-1 such that the merging distance between levels l and l-1 is larger than the C.atol struct field. The search starts from l = 1, l-1 = 0 (the leaf level). \n\n\n\n\n\npicklevel(C::UseCumulativeSLDistance, pt::PartitionTree{T}, args...)::Int where T <: AbstractFloat\n\nSee UseSLDistance for a description of merging distance. Returns the partition for level l-1 such that the cumulative sum of merging distances from the level 0 (the leaf level) to level lis larger than the C.atol struct field. The search starts from l = 1, l-1 = 0. \n\n\n\n\n\npicklevel(\n    C::UseMaxDeviation{T},\n    pt::PartitionTree{T},\n    X,\n)::Int where T <: AbstractFloat\n\nReturns an approximate best match partition from pt such that its maximum deviation is approximately a best match to C.max_dev.\n\nUse a bracketing binary search between levels 0 and getmaxlevel(pt). See UseMaxDeviation for further details on the terminology.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"computemaxdeviation","category":"page"},{"location":"api/#SingleLinkagePartitions.computemaxdeviation","page":"Public API","title":"SingleLinkagePartitions.computemaxdeviation","text":"computemaxdeviation(\n    X::Union{Vector{Vector{T}}, Vector{Vector{Complex{T}}}},\n    pt::PartitionTree,\n    level::Integer,\n) where T <: AbstractFloat\n\nThis version extracts the partition assocaited with level from pt, then calls computemaxdeviation(X, partition).\n\n\n\n\n\ncomputemaxdeviation(\n    X::Union{Vector{Vector{T}}, Vector{Vector{Complex{T}}}},\n    partition::Vector{Vector{Int}},\n) where T <: AbstractFloat\n\nGiven a point set X on a D-dimensional vector space, we define the maximum deviation of a partition P_X of X as:\n\nρ = maximum(\n    maximum(\n        maximum(\n            abs(a[d]-mean(A)[d])\n            for a in A\n        )\n        for A in P_X\n    )\n    for d in 1:D\n)\n\ncomputemaxdeviation computes ρ a bit more efficiently, with  '''julia P_X = collect( X[partition[k]] for k in eachindex(partition) ) '''\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"iteratedsl","category":"page"},{"location":"api/#SingleLinkagePartitions.iteratedsl","page":"Public API","title":"SingleLinkagePartitions.iteratedsl","text":"iteratedsl(\n    level_config::UseMaxDeviation,\n    metric::MetricType,\n    X0::Union{Vector{Vector{T}}, Vector{Vector{Complex{T}}}};\n    acceptance_factor::T = convert(T, 0.7),\n    max_iter = 100,\n)::Tuple{Vector{Vector{Int}}, Int} where T <: AbstractFloat\n\nReturns a partition P, anditers_ran. Iteratively run single-linkage clustering withUseMaxDeviation andpicklevel(` to select a partition at every iteration. Some of the parts in the selected partition are chosen to be moved to a solution partition, and the associated points won't be used for the next iteration of single-linkage clustering. See the documentation website for details on the iteration algorithm, including terminating conditions.\n\n\n\n\n\n","category":"function"},{"location":"api/#Get/Set-routines","page":"Public API","title":"Get/Set routines","text":"","category":"section"},{"location":"api/#Partition-tree-data-type-PartitionTree","page":"Public API","title":"Partition tree data type PartitionTree","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"getmaxlevel","category":"page"},{"location":"api/#SingleLinkagePartitions.getmaxlevel","page":"Public API","title":"SingleLinkagePartitions.getmaxlevel","text":"getmaxlevel(pt::PartitionTree)::Int\n\nReturns the maximum level of the partition tree.\n\nA valid level for pt can take integer values in [0, getmaxlevel(pt)]. A level indexes a partition in pt.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"getpartition","category":"page"},{"location":"api/#SingleLinkagePartitions.getpartition","page":"Public API","title":"SingleLinkagePartitions.getpartition","text":"getpartition(pt::PartitionTree, level::Integer)::Vector{Vector{Int}}\n\nlevel indicates the number of merges that occured to produce a partition. Think of it as an index from 0 to max_level = getmaxlevel(pt).\n\nWe use the terminology part to mean an element (i.e. a subset) of a partition. Some folks call it a cluster.\n\nlevel == 0 corresponds to the leaf level where each point is assigned its own part (i.e. cluster), i.e., we have only singleton parts.\n\nThe maximum level, level == getmaxlevel(pt), corresponds to the root level where all points are assigned to be in the same part.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"getdistances","category":"page"},{"location":"api/#SingleLinkagePartitions.getdistances","page":"Public API","title":"SingleLinkagePartitions.getdistances","text":"getdistances(pt::PartitionTree{T})::Vector{T} where T <: AbstractFloat\n\nReturns the set of minimum distanes between consecutive nested partitions. If pt was constructed from N points, then there are N-1 entries in the returned 1-D array of distances.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"generateallpartitions","category":"page"},{"location":"api/#SingleLinkagePartitions.generateallpartitions","page":"Public API","title":"SingleLinkagePartitions.generateallpartitions","text":"generateallpartitions(pt::PartitionTree)::Vector{Vector{Vector{Int}}}\n\nreturns the set of all partitions in the partition tree, partition_set If N points was used to generate the partition tree pt, then:\n\npartition_set has N+1 entries. Each entry is a partition.\nGiven the input point set that generated pt, call it X::Vector{Vector{T}}, a partition index 1 <= m <= N+1, part index k, part member index i, if we assign z = partition_set[m][k][i], then X[z] is point that belongs to the m-th partition, k-th part/cluster in the partition, and it is the i-th point in that part/cluster.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"getlargestdistance","category":"page"},{"location":"api/#SingleLinkagePartitions.getlargestdistance","page":"Public API","title":"SingleLinkagePartitions.getlargestdistance","text":"getlargestdistance(pt::PartitionTree{T})::Vector{T} where T <: AbstractFloat\n\nReturns the largest merge/single-linkage distance.\n\n\n\n\n\n","category":"function"},{"location":"#SingleLinkagePartitions.jl","page":"Overview","title":"SingleLinkagePartitions.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"This package implements the single-linkage clustering algorithm via a minimum spanning tree approach. It is suitable for handling data that can fit in the local machine's RAM.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Single-linkage clustering is a hierarchical clustering method, which means for a dataset of N points in mathbbR^D, it generates a set of N nested partitions. The implementation here uses a minimum-spanning tree, which should offer some efficiency and flexibility than the naive single-linkage clustering algorithm.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The documentation is on-going, but demo walk-throughs for the chaining example as well as the quick-start examples in the README.MD file should address most basic usage cases. A walkthrough for merging points might be authored in the future.","category":"page"},{"location":"#Terminology-and-algorithms","page":"Overview","title":"Terminology and algorithms","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"I devised some strategies to select a partition given a computed single-linkage partition tree. This section describes the terminologies and algorithms associated with these strategies.","category":"page"},{"location":"#Pick-a-partition-based-on-maximum-deviation","page":"Overview","title":"Pick a partition based on maximum deviation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Let the dimension of the input array be D. Given a positive integer L, the L-th order Riesz transform is a collection of iterated Riesz transforms, each of which is specified by a multi-index a in mathbbAleft(DLright). The index set is defined as:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The dimensional maximum deviation from the mean of a point set AsubsetmathbbR^D is defined as: ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"beginalign*\nrho_textdimleft(Aright)  =left max_ain Aleft lefta_d-mu_Adrightright right _dinleftDrightcongbeginbmatrixmax_ain Aleft lefta_1-mu_A1rightright \nmax_ain Aleft lefta_2-mu_A2rightright \nvdots\nmax_ain Aleft lefta_D-mu_ADrightright \nendbmatrix\nbarrho_textdimleft(Aright)  =maxrho_textdimleft(Aright)\n  =max_dinleftDrightain Aleft lefta_d-mu_Adrightright \nendalign*","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The subscripts mean the coordinates of the point ain A, and mu_A is the average of the points in A.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Let XsubsetmathbbR^D be a finite point set, and P_X be a partition of X. The maximum deviation from the mean of a partition P_X of a point set X is defined as:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"beginalign*\nrholeft(P_Xright)  =max_Uin P_Xleft barrho_textdimleft(Uright)right \n  =max_Uin P_XdinleftDrightain Ulefta_d-mu_Udright\nendalign*","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Each partition tree level linleft 01cdotsLright corresponds to a partition, which we denote by P_Xl. The squence left rholeft(P_Xlright)right _l is approximately monotonically increasing, so a bracketed binary search algorithm is used to find a partition that approximately best matches a specified target rho_texttarget.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"After the binary search, if the selected partition X_l has tree index l, and exceeds rho_texttarget, then we the sequence kinleft l-1l-2cdots0right until we have rholeft(P_X_lright)rho_texttarget. Therefore, we gaurantee that the select partition has a maximum deviation that is less than rho_texttarget.","category":"page"},{"location":"#Iteration-scheme","page":"Overview","title":"Iteration scheme","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"When we want to reduce the chaining behavior, we could iteratively restart single-linkage clustering for smaller and smaller subsets of the original point set X. My algorithm is as follows:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Initialize R_0 to the empty set, and X_0=X.\nFor each iteration j, we want to compute the j-th iteration","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"update set M_j, the results set of subsets R_j, and the process set X_j. ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"For the j-th iteration:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Pick a partition P_X_j from the tree via the maximum deviation strategy discussed earlier.\nDefine the threshold tau_j=betacdotrholeft(P_X_jright), where the user-specific acceptance factor betainleft(01right) is used to make sure tau_j approaches a maximum of rholeft(P_X_jright).\nPerform the update:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"beginalign*\nM_j  =left Uin P_X_jmidbarrho_textdimleft(Uright)geqtau_jright \nR_j  =R_j-1cup M_j\nX_j  =X_j-1setminus M_j\nendalign*","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Check for the following stopping conditions. Increment j and repeat from step 1 if conditions are not met. Upon exit of this iterative procedure, R_j for the termination iteration j should be a partition of X.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"If X_j is empty, then exit with no post-processing.\nIf X_j has only one point, then add that point as a singleton subset into R_j, then exit.\nIf M_j is empty, then assign R_j=R_j-1cup P_X_j and exit.","category":"page"},{"location":"#Citation","page":"Overview","title":"Citation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"You can use the Cite This Repository button below the About section on the GitHub webpage of this repository.","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"EditURL = \"../../../examples/chaining.jl\"","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"run the contents of preproc.txt to generate markdown. # hide","category":"page"},{"location":"generated/chaining/#Load-dependencies-for-this-demo","page":"Demo: chaining & remedy","title":"Load dependencies for this demo","text":"","category":"section"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"run using Pkg; Pkg.add(\"name-of-dependency) if you have missing dependencies.","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"import SingleLinkagePartitions as SL\n\nimport PythonPlot as PLT # visualization\n\nusing LinearAlgebra\nimport Statistics\n\nimport Random\nRandom.seed!(25)\n\nPLT.close(\"all\")\nfig_num = 1","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"1","category":"page"},{"location":"generated/chaining/#Set-up-data","page":"Demo: chaining & remedy","title":"Set up data","text":"","category":"section"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"T = Float64\nD = 2;","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"oracle set to one branch of Fermat's spiral","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"f = tt->(sqrt(tt) .* [cos(tt); sin(tt)]);","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"sample data from the oracle to get our 2-D point set, X.","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"N = 10\nts = LinRange(0, 2*π, N)\nX = collect( f(t) for t in ts ); # this is our data, the input point set for this demo.","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"visualize the data.","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"plot_x = collect( X[n][begin] for n in eachindex(X) )\nplot_y = collect( X[n][begin+1] for n in eachindex(X) )\n\nPLT.figure(fig_num)\nfig_num += 1\nPLT.scatter(plot_x, plot_y, marker = \"x\")\nPLT.axis(\"scaled\")\nPLT.title(\"Input point set\")\nPLT.gcf()","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"(Image: )","category":"page"},{"location":"generated/chaining/#Single-linkage-clustering","page":"Demo: chaining & remedy","title":"Single-linkage clustering","text":"","category":"section"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"Single-linkage clustering is a method to generate a partition tree, which is a set of nested partitions. First, specify the distance metric.","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"metric = SL.geteuclideanmetric()","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"SingleLinkagePartitions.DistancesjlMetric{Distances.Euclidean}(Distances.Euclidean(0.0))","category":"page"},{"location":"generated/chaining/#Generate-partition-tree","page":"Demo: chaining & remedy","title":"Generate partition tree","text":"","category":"section"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"pt = SL.computesl(metric, X)","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"SingleLinkagePartitions.PartitionTree{Float64}(10, [2, 1, 3, 4, 5, 6, 7, 8, 9], [3, 2, 4, 5, 6, 7, 8, 9, 10], [0.7627270355420898, 0.8355427582103335, 0.9331048795315017, 1.087069198275422, 1.2246589300873207, 1.3494477463111696, 1.4642107178915054, 1.5709307361417881, 1.6710426337120232])","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"The minimum distances between the nested partitions.","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"distance_set = SL.getdistances(pt) # length(distance_set) == length(X) - 1.","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"9-element Vector{Float64}:\n 0.7627270355420898\n 0.8355427582103335\n 0.9331048795315017\n 1.087069198275422\n 1.2246589300873207\n 1.3494477463111696\n 1.4642107178915054\n 1.5709307361417881\n 1.6710426337120232","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"The nested partitions in the partition tree.","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"partition_set = SL.generateallpartitions(pt) # length(partition_set) == length(X).","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"10-element Vector{Vector{Vector{Int64}}}:\n [[1], [2], [3], [4], [5], [6], [7], [8], [9], [10]]\n [[1], [2, 3], [4], [5], [6], [7], [8], [9], [10]]\n [[1, 2, 3], [4], [5], [6], [7], [8], [9], [10]]\n [[1, 2, 3, 4], [5], [6], [7], [8], [9], [10]]\n [[1, 2, 3, 4, 5], [6], [7], [8], [9], [10]]\n [[1, 2, 3, 4, 5, 6], [7], [8], [9], [10]]\n [[1, 2, 3, 4, 5, 6, 7], [8], [9], [10]]\n [[1, 2, 3, 4, 5, 6, 7, 8], [9], [10]]\n [[1, 2, 3, 4, 5, 6, 7, 8, 9], [10]]\n [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"visualize a few partitions at different levels","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"marker_size = 100.5\nmax_level = SL.getmaxlevel(pt)","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"9","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"25 percent from leaf (all singleton parts) to root (every point is in the same part).","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"level = round(Int, Statistics.quantile(0:max_level, 0.25))\npartition = SL.getpartition(pt, level)\n\ntitle_string = \"Partition from the 25% quantile level (from leaf to root)\"\nARGS = (partition, title_string, X, fig_num, marker_size) # hide\n\npartition, title_string, X, fig_num, marker_size = ARGS\n\nPLT.figure(fig_num)\nfig_num += 1\n\nfor k in eachindex(partition)\n    X_part = X[partition[k]]\n    plot_x = collect( X_part[n][begin] for n in eachindex(X_part) )\n    plot_y = collect( X_part[n][begin+1] for n in eachindex(X_part) )\n\n    if length(X_part) < 2\n        PLT.scatter(plot_x, plot_y, s = marker_size, label = \"part $k\", marker = \"x\")\n    else\n        PLT.scatter(plot_x, plot_y, s = marker_size, label = \"part $k\")\n    end\nend\n\nPLT.axis(\"scaled\")\nPLT.title(title_string)\nPLT.legend()\nPLT.gcf()","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"(Image: )","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"50 percent from leaf (all singleton parts) to root (every point is in the same part).","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"level = round(Int, Statistics.quantile(0:max_level, 0.50))\npartition = SL.getpartition(pt, level)\n\ntitle_string = \"Partition from the 50% quantile level (from leaf to root)\"\nARGS = (partition, title_string, X, fig_num, marker_size) # hide\n\npartition, title_string, X, fig_num, marker_size = ARGS\n\nPLT.figure(fig_num)\nfig_num += 1\n\nfor k in eachindex(partition)\n    X_part = X[partition[k]]\n    plot_x = collect( X_part[n][begin] for n in eachindex(X_part) )\n    plot_y = collect( X_part[n][begin+1] for n in eachindex(X_part) )\n\n    if length(X_part) < 2\n        PLT.scatter(plot_x, plot_y, s = marker_size, label = \"part $k\", marker = \"x\")\n    else\n        PLT.scatter(plot_x, plot_y, s = marker_size, label = \"part $k\")\n    end\nend\n\nPLT.axis(\"scaled\")\nPLT.title(title_string)\nPLT.legend()\nPLT.gcf()","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"(Image: )","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"75 percent from leaf (all singleton parts) to root (every point is in the same part).","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"level = round(Int, Statistics.quantile(0:max_level, 0.75))\npartition = SL.getpartition(pt, level)\n\ntitle_string = \"Partition from the 75% quantile level (from leaf to root)\"\nARGS = (partition, title_string, X, fig_num, marker_size) # hide\n\npartition, title_string, X, fig_num, marker_size = ARGS\n\nPLT.figure(fig_num)\nfig_num += 1\n\nfor k in eachindex(partition)\n    X_part = X[partition[k]]\n    plot_x = collect( X_part[n][begin] for n in eachindex(X_part) )\n    plot_y = collect( X_part[n][begin+1] for n in eachindex(X_part) )\n\n    if length(X_part) < 2\n        PLT.scatter(plot_x, plot_y, s = marker_size, label = \"part $k\", marker = \"x\")\n    else\n        PLT.scatter(plot_x, plot_y, s = marker_size, label = \"part $k\")\n    end\nend\n\nPLT.axis(\"scaled\")\nPLT.title(title_string)\nPLT.legend()\nPLT.gcf()","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"(Image: )","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"We can see that only a single part gets larger and larger. This is because the minimum distance between all parts for a partition at a given level is one that involves the large part. This is a known characteristic with single-linkage clustering, which may be something that is desirable or undesirable, depending on the application.","category":"page"},{"location":"generated/chaining/#Select-a-level-(i.e.-partition)-via-conditions","page":"Demo: chaining & remedy","title":"Select a level (i.e. partition) via conditions","text":"","category":"section"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"The conditions implemented are: UseMaxDeviation, UseSLDistance, and UseCumulativeSLDistance. We'll focus on UseMaxDeviation in this demo. The docstrings for UseSLDistance and UseCumulativeSLDistance should be self-explantory, and the method picklevel that we'll describe is impelemnted for them as well.","category":"page"},{"location":"generated/chaining/#UseMaxDeviation:-Deivation-from-part/cluster-mean/centroid.","page":"Demo: chaining & remedy","title":"UseMaxDeviation: Deivation from part/cluster mean/centroid.","text":"","category":"section"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"Please review the terminology section before proceeding. First, specify an allowed deviation distance.","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"max_dev = pt.w[end]/2 # we arbitrarily choose half of the largest single-linkage distance from the tree.\nlevel_config = SL.UseMaxDeviation(max_dev)\n\nlevel = SL.picklevel(level_config, pt, X) # pick level via binary search.\npartition = SL.getpartition(pt, level)","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"7-element Vector{Vector{Int64}}:\n [1, 2, 3, 4]\n [5]\n [6]\n [7]\n [8]\n [9]\n [10]","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"We see that the maximum deviation sequence when ordered by the nesting order of the partition tree (i.e. from level = 0 the leaf to level == getmaxlevel(pt) the root) is approximately monotonic.","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"max_ds = collect(\n    SL.computemaxdeviation(X, pt, level)\n    for level in 0:(SL.getmaxlevel(pt))\n)\nPLT.figure(fig_num)\nfig_num += 1\nPLT.plot(0:(SL.getmaxlevel(pt)), max_ds, \"o\")\n#PLT.axis(\"scaled\")\nPLT.xlabel(\"Level index, in the nested order\")\nPLT.ylabel(\"The Maximum deviation of a partition\")\nPLT.title(\"Maximum deviation of all partitions in the tree\")\nPLT.gcf()","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"(Image: )","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"Since it is approximately monotonic, we use a bracketed binary search to select a partition such that its maximum deviation is approximate the best match from all the partitions to the specified value max_dev. We then do a linear search from this search result in the reverse nesting order to find the first partition that has a smaller maximum deviation. Please see the terminology section for details. One can alternatively do a linear search over max_ds to pick a level, which is easy to implement yourself given max_ds`.","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"level = SL.picklevel(level_config, pt, X) # pick level via binary search.\npartition = SL.getpartition(pt, level) # instantiate the partition given the level and tree.\n\nprintln(\"Target maximum deviation: \", max_dev)\nprintln(\"Selected partition's maximum deviation: \", SL.computemaxdeviation(X, pt, level));","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"Target maximum deviation: 0.8355213168560116\nSelected partition's maximum deviation: 0.7540138928489456\n","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"visualize","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"title_string = \"Partition selected via UseMaxDeviation\"\nARGS = (partition, title_string, X, fig_num, marker_size) # hide\n\npartition, title_string, X, fig_num, marker_size = ARGS\n\nPLT.figure(fig_num)\nfig_num += 1\n\nfor k in eachindex(partition)\n    X_part = X[partition[k]]\n    plot_x = collect( X_part[n][begin] for n in eachindex(X_part) )\n    plot_y = collect( X_part[n][begin+1] for n in eachindex(X_part) )\n\n    if length(X_part) < 2\n        PLT.scatter(plot_x, plot_y, s = marker_size, label = \"part $k\", marker = \"x\")\n    else\n        PLT.scatter(plot_x, plot_y, s = marker_size, label = \"part $k\")\n    end\nend\n\nPLT.axis(\"scaled\")\nPLT.title(title_string)\nPLT.legend()\nPLT.gcf()","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"(Image: )","category":"page"},{"location":"generated/chaining/#Iterated-single-linkage-to-reduce-chaining","page":"Demo: chaining & remedy","title":"Iterated single-linkage to reduce chaining","text":"","category":"section"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"If it is desirable to reduce chaining, then we can use an iterated version of picklevel(). So far, only UseMaxDeviation is implemented for iteration. We need to specify the iteration, namely a discount factor-like parameter that characterizes our acceptance of a selected partition in every iteration.","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"acceptance_factor = 0.99","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"0.99","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"acceptance_factor is a value in (0,1). closest to 1 means almost only the part with the maximum dev is added to P. A larger value for acceptance_factor` tend to yield fewer parts in the final P.","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"Run the iteration to assemble a partition P of X that has less chaining behavior. Note that P is not from the set of nested partitions in the single-linkage partition tree of X. See the terminology section of the documentation website for more details.","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"P, iters_ran = SL.iteratedsl(\n    level_config,\n    SL.geteuclideanmetric(),\n    X;\n    acceptance_factor = acceptance_factor,\n    max_iter = 100,\n)\nmax_dev_P = SL.computemaxdeviation(X, partition)","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"0.7540138928489456","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"visualize","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"partition = P\ntitle_string = \"Partition selected via iteratedsl\"\nARGS = (partition, title_string, X, fig_num, marker_size) # hide\n\npartition, title_string, X, fig_num, marker_size = ARGS\n\nPLT.figure(fig_num)\nfig_num += 1\n\nfor k in eachindex(partition)\n    X_part = X[partition[k]]\n    plot_x = collect( X_part[n][begin] for n in eachindex(X_part) )\n    plot_y = collect( X_part[n][begin+1] for n in eachindex(X_part) )\n\n    if length(X_part) < 2\n        PLT.scatter(plot_x, plot_y, s = marker_size, label = \"part $k\", marker = \"x\")\n    else\n        PLT.scatter(plot_x, plot_y, s = marker_size, label = \"part $k\")\n    end\nend\n\nPLT.axis(\"scaled\")\nPLT.title(title_string)\nPLT.legend()\nPLT.gcf()","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"(Image: )","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"This concludes the demo","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"nothing # hide","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"","category":"page"},{"location":"generated/chaining/","page":"Demo: chaining & remedy","title":"Demo: chaining & remedy","text":"This page was generated using Literate.jl.","category":"page"}]
}
